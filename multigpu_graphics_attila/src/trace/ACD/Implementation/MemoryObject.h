/**************************************************************************
 *
 * Copyright (c) 2002 - 2011 by Computer Architecture Department,
 * Universitat Politecnica de Catalunya.
 * All rights reserved.
 *
 * The contents of this file may not be disclosed to third parties,
 * copied or duplicated in any form, in whole or in part, without the
 * prior permission of the authors, Computer Architecture Department
 * and Universitat Politecnica de Catalunya.
 *
 */

#ifndef MEMORYOBJECT
    #define MEMORYOBJECT

#include <map>
#include <vector>
#include <set>
#include "ACDResource.h"

namespace acdlib
{

/**
 * Possible memory object states
 */
enum MemoryObjectState
{
    MOS_ReAlloc,        ///< Indicates that the object region must be fully reallocated (previous contents can be discarded)
    MOS_NotSync,        ///< Indicates that the object region requires update
    MOS_Sync,           ///< The object region does not required updating CPU & GPU memory are synchronized
    MOS_Blit,           ///< GPU memory is updated (due to a blit op), CPU memory not. The only transition accepted is to MOS_REALLOC.
    MOS_RenderBuffer,   ///< Objects stores data generated by the GPU.
    MOS_NotFound,       ///< The region queried does not exist
};



/**
 * MemoryObject adds support for CPU/GPU memory synchronization and priorization
 *
 * All resource objects implementations (textures, buffers, etc) must inherit from this base
 * abstract class
 *
 * This class implements the state concept of resources, each resource has a number of states
 * equeals to its number of memory regions
 *
 * @author Carlos González (cgonzale@ac.upc.edu)
 * @date 02/19/2007
 */
class MemoryObject
{

friend class MemoryObjectAllocator;

public:

    /**
     * Defines the preferred memory locations for memory objects
     */
    enum MemoryType
    {
        MT_SystemMemory, ///< Data object will be stored in system user memory
        MT_LocalMemory, ///< Data will be allocated in local GPU memory
    };

    /**
     * COnstructor automatically called by each subclass
     */
    MemoryObject();

    std::vector<acd_uint> getDefinedRegions() const;


    /**
     * Gets the memory object state of a memory object region
     *
     * @param region the region to query
     *
     * @note If the region does not exist, MOS_NotFound is returned
     */
    MemoryObjectState getState(acd_uint region) const;

    /**
     * This method retrives a value indicating the number of reallocations posted till now
     *
     * This method can be used to warranty that a MemoryObject REGION has not been reallocated
     * between a range of time
     *
     * @code
     *
     *    MemoryObject* mo = ...;
     *
     *    // At certain time
     *    acd_uint old = m->trackRealloc();
     *
     *    // Later
     *
     *    if ( m->trackRealloc() == old ) {
     *       // Can execute code that assumes that memory object has the same @ in GPU
     *    }
     * 
     */
    acd_uint trackRealloc(acd_uint region) const;


    /**
     * Set the lock state of a given region
	 *
     */
	void lock(acd_uint region, acd_bool lock);

    /**
     * This method retrives a value indicating if the memory region is previouly used in the previous frame
	 *
	 * @returns if the region is locked
     */
	acd_bool isLocked(acd_uint region) const;

    /**
     * Set the preload data state of a given region
	 *
     */
	void preload(acd_uint region, acd_bool preload);

    /**
     * This method retrives a value indicating if the memory region is to be preload into GPU memory (zero simulation cycles).
	 *
	 * @returns if the region contain preload data.
     */
	acd_bool isPreload(acd_uint region) const;

    /**
     * This method retries a value indicating the number of reallocations posted till now
     *
     * This method differs from the REGION version since it tracks all region reallocations
     * in the same variable. It provides a method to verify if any REGION of the resource
     * has been reallocated
     *
     * @returns Sum of reallocations of each resource region
     */
    acd_uint trackRealloc() const;

    /**
     * Sets which memory is preferred to allocate this object
     */
    void setPreferredMemory(MemoryType mem);

    /**
     * Gets which is the preferred memory to allocate this memory object
     */
    MemoryType getPreferredMemory() const;

    /**
     * Gets a pointer to the binary data of a memory object region
     *
     * The memory layout is the required GPU memory layout
     *
     * @param region The memory region selected
     * @retval memorySizeInBytes the size of the memory region selected (in bytes)
     */
    virtual const acd_ubyte* memoryData(acd_uint region, acd_uint& memorySizeInBytes) const = 0;

    /**
     * Obtains the memory object region range that requires updating based on
     * The eg
     *
     * @param region Region queried
     * @retval startByte First byte retrived with memoryData() method that requires updating
     * @retval lastByte Last byte retrieved with memoryData() method that requires updating
     */
    void getUpdateRange(acd_uint region, acd_uint& startByte, acd_uint& lastByte);

    /**
     * Each subclass should define its own string type
     */
    virtual const acd_char* stringType() const;

    void postBlit(acd_uint region);

    void postRenderBuffer(acd_uint region);

    void syncGPU(acd_uint region, acd_uint gpuId);
    bool isSynced(acd_uint region, acd_uint gpuId);
    bool anyGPUSynced(acd_uint region);
    void clearSyncedGPUIds(acd_uint region);
    MemoryObjectState getStateBeforeSync(acd_uint region);
    void setStateBeforeSync(acd_uint region, MemoryObjectState stateBeforeSync);

protected:

    /**********************
     * Post state methods *
     **********************/
    void postUpdate(acd_uint region, acd_uint startByte, acd_uint lastByte);
    void postUpdateAll();
    void postReallocate(acd_uint region);
    void postReallocateAll();
    
    void postBlitAll();
    
    void postRenderBufferAll();

    // Must be called by subclasses to init region information, when a region must be defined
    void defineRegion(acd_uint region);
    void undefineRegion(acd_uint region);

private:

    // Can only be called by MemoryObjectAllocator
    void changeState(acd_uint region, MemoryObjectState newState);
    
    MemoryType _preferredMemory;

    struct MemoryObjectRegion
    {
        MemoryObjectState state;
        acd_uint firstByteToUpdate;
        acd_uint lastByteToUpdate;
        acd_uint reallocs;
	acd_uint locked;
	acd_bool preload;

	std::set<acd_uint> syncedGPUIds;
        MemoryObjectState stateBeforeSync;
    };

    std::map<acd_uint, MemoryObjectRegion> mor;

    acd_uint _globalReallocs;

    void _postUpdate(acd_uint moID, MemoryObjectRegion& moRegion, acd_uint startByte, acd_uint lastByte);


};

}


#endif // MEMORYOBJECT
